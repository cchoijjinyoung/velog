<p>소프트웨어 개발의 핵심 목표 중 하나는 변화에 적응할 수 있는 시스템을 구축하는 것입니다. 소프트웨어는 시간이 지남에 따라 새로운 요구 사항이 추가되고, 기존의 요구 사항이 변경되며, 기술적 환경이 바뀌는 등의 상황을 겪습니다. 이러한 변화에 유연하게 대응하기 위해 객체지향 프로그래밍(OOP)이 중요한 역할을 합니다. 이번 글에서는 객체지향 프로그래밍의 기본 개념과 설계 원칙을 깊이 있게 살펴보겠습니다.</p>
<hr />
<h3 id="유지보수란-무엇인가">유지보수란 무엇인가?</h3>
<p>소프트웨어 유지보수는 단순히 기존의 상태를 유지하는 것이 아니라, 변화하는 환경 속에서도 기능과 유용성을 유지하는 것을 의미합니다. 유지보수를 잘 설계하기 위해서는 변화를 최소한의 비용으로 수용할 수 있는 구조가 필요합니다. 객체지향 프로그래밍은 이러한 요구를 충족시키기 위해 설계 단계부터 변화에 강한 시스템을 만드는 데 초점을 둡니다.</p>
<hr />
<h3 id="객체란-무엇인가">객체란 무엇인가?</h3>
<p>객체의 본질: 기능 제공</p>
<p>객체란 내부적으로 어떤 데이터를 보유하고 있는지가 아니라, 외부에 어떤 기능을 제공하는가로 정의됩니다. 객체는 데이터를 단순히 저장하는 역할을 넘어, 해당 데이터와 관련된 기능을 수행할 책임을 가집니다.</p>
<pre><code class="language-java">예시)
Member 객체:
- 암호 변경하기
- 차단 여부 확인하기

소리 제어기 객체:
- 소리 크기 증가/감소</code></pre>
<p>단순히 <code>getter</code>와 <code>setter</code>만 있는 클래스는 객체라기보다는 단순한 데이터 구조에 불과합니다. 객체는 외부로부터 데이터를 가져와 처리하는 대신, 데이터를 자신의 책임 아래 처리하도록 설계되어야 합니다.</p>
<hr />
<h3 id="캡슐화-내부-구현을-감추기">캡슐화: 내부 구현을 감추기</h3>
<p>캡슐화는 객체가 제공하는 기능의 구현 세부 사항을 외부에 감추는 것을 의미합니다. 이를 통해 객체 간의 의존성을 줄이고, 시스템의 안정성을 높일 수 있습니다.</p>
<h3 id="tell-dont-ask">Tell, Don't Ask</h3>
<p>객체는 데이터를 외부에서 가져와 처리하게 하지 말고, 필요한 작업을 객체에 직접 요청하도록 설계해야 합니다.</p>
<pre><code class="language-java">// 나쁜 예시
if (account.getMembership() == REGULAR) {
    // do something
}

// 좋은 예시
if (account.hasRegularPermission()) {
    // do something
}</code></pre>
<h3 id="디미터-법칙demeters-law">디미터 법칙(Demeter's Law)</h3>
<p>디미터 법칙은 객체 간의 불필요한 의존을 줄이기 위한 설계 원칙입니다. 이 법칙은 메서드에서 호출할 수 있는 객체를 제한합니다.</p>
<ul>
<li>메서드에서 생성한 객체의 메서드만 호출</li>
<li>파라미터로 받은 객체의 메서드만 호출</li>
<li>필드로 참조하는 객체의 메서드만 호출</li>
</ul>
<pre><code class="language-java">// 나쁜 예시
if (account.getExpDate().isAfter(now)) {
    // do something
}

// 좋은 예시
if (account.isExpired(now)) {
    // do something
}</code></pre>
<hr />
<h3 id="추상화-수정에는-닫혀-있고-확장에는-열려-있어야-한다">추상화: 수정에는 닫혀 있고 확장에는 열려 있어야 한다</h3>
<p>추상화는 <strong>OCP(Open/Closed Principle)</strong> 를 따르는 설계의 핵심입니다. OCP란 &quot;수정에는 닫혀 있고, 확장에는 열려 있어야 한다&quot;는 원칙으로, 새로운 기능을 추가할 때 기존 코드를 수정하지 않도록 설계하는 것을 목표로 합니다. 이를 위해 인터페이스나 추상 클래스를 사용해 시스템을 설계합니다.</p>
<hr />
<h3 id="상속보다는-조립을-고려하라">상속보다는 조립을 고려하라</h3>
<p>상속은 강력한 기능 재사용 도구이지만, 남용할 경우 다음과 같은 문제가 발생할 수 있습니다:</p>
<ul>
<li>상위 클래스 변경의 어려움</li>
<li>클래스 수 증가</li>
<li>상속 구조의 오용</li>
</ul>
<h3 id="조립으로-문제-해결">조립으로 문제 해결</h3>
<p>기능 재사용이 필요할 때는 <strong>조립(Composition)</strong> 을 우선적으로 고려해야 합니다. 조립은 객체 간의 협력을 통해 기능을 재사용하도록 설계하며, 이를 통해 상속의 단점을 극복할 수 있습니다.</p>
<hr />
<h3 id="기능과-책임의-분리">기능과 책임의 분리</h3>
<p><strong>하나의 기능은 여러 하위 기능으로 구성된다</strong></p>
<p>객체는 하나의 책임만을 가져야 하며, 이를 통해 각 객체의 역할이 명확해집니다. 이를 <strong>단일 책임 원칙(Single Responsibility Principle, SRP)</strong> 이라고 합니다.</p>
<p>예시: 암호 변경 기능</p>
<ol>
<li>변경 대상 확인 (없을 시 오류 발생) → MemberRepository</li>
<li>대상 암호 변경 → Member</li>
</ol>
<p>책임을 명확히 분리하면:</p>
<ul>
<li>클래스의 역할이 명확해지고,</li>
<li>테스트와 유지보수가 용이해집니다.</li>
</ul>
<hr />
<h3 id="dipdependency-inversion-principle-의존-역전-원칙">DIP(Dependency Inversion Principle): 의존 역전 원칙</h3>
<p>고수준 모듈(비즈니스 로직)이 저수준 모듈(데이터베이스, 네트워크 등)에 의존하지 않도록 설계해야 합니다. 이를 위해 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존하도록 만듭니다.</p>
<p><code>예시 : Service → Repository (interface) ← RepositoryImpl → JpaRepository</code></p>
<p>이 원칙을 따르면, 저수준 모듈의 변경이 고수준 모듈에 영향을 미치지 않으므로 시스템의 유연성이 향상됩니다.</p>
<hr />
<h3 id="테스트를-강조하는-이유">테스트를 강조하는 이유</h3>
<p>테스트하기 쉬운 코드는 좋은 설계일 확률이 높습니다. 의존성이 잘 풀려 있다면 테스트 작성이 훨씬 간단해지고, 유지보수와 확장이 용이해집니다.</p>